import { TemplateRef, Type } from '@angular/core';
import { FlexRenderComponent } from './flex-render-component';
export function mapToFlexRenderTypedContent(content) {
    if (content === null || content === undefined) {
        return { kind: 'null' };
    }
    if (typeof content === 'string' || typeof content === 'number') {
        return { kind: 'primitive', content };
    }
    if (content instanceof FlexRenderComponent) {
        return { kind: 'flexRenderComponent', content };
    }
    else if (content instanceof TemplateRef) {
        return { kind: 'templateRef', content };
    }
    else if (content instanceof Type) {
        return { kind: 'component', content };
    }
    else {
        return { kind: 'primitive', content };
    }
}
export class FlexRenderView {
    view;
    #previousContent;
    #content;
    constructor(initialContent, view) {
        this.#content = initialContent;
        this.view = view;
    }
    get previousContent() {
        return this.#previousContent ?? { kind: 'null' };
    }
    get content() {
        return this.#content;
    }
    set content(content) {
        this.#previousContent = this.#content;
        this.#content = content;
    }
}
export class FlexRenderTemplateView extends FlexRenderView {
    constructor(initialContent, view) {
        super(initialContent, view);
    }
    updateProps(props) {
        this.view.markForCheck();
    }
    dirtyCheck() {
        // Basically a no-op. When the view is created via EmbeddedViewRef, we don't need to do any manual update
        // since this type of content has a proxy as a context, then every time the root component is checked for changes,
        // the property getter will be re-evaluated.
        //
        // If in a future we need to manually mark the view as dirty, just uncomment next line
        // this.view.markForCheck()
    }
    onDestroy(callback) {
        this.view.onDestroy(callback);
    }
}
export class FlexRenderComponentView extends FlexRenderView {
    constructor(initialContent, view) {
        super(initialContent, view);
    }
    updateProps(props) {
        switch (this.content.kind) {
            case 'component': {
                this.view.setInputs(props);
                break;
            }
            case 'flexRenderComponent': {
                // No-op. When FlexRenderFlags.PropsReferenceChanged is set,
                // FlexRenderComponent will be updated into `dirtyCheck`.
                break;
            }
        }
    }
    dirtyCheck() {
        switch (this.content.kind) {
            case 'component': {
                // Component context is currently valuated with the cell context. Since it's reference
                // shouldn't change, we force mark the component as dirty in order to re-evaluate function invocation in view.
                // NOTE: this should behave like having a component with ChangeDetectionStrategy.Default
                this.view.markAsDirty();
                break;
            }
            case 'flexRenderComponent': {
                // Given context instance will always have a different reference than the previous one,
                // so instead of recreating the entire view, we will only update the current view
                if (this.view.eqType(this.content.content)) {
                    this.view.update(this.content.content);
                }
                this.view.markAsDirty();
                break;
            }
        }
    }
    onDestroy(callback) {
        this.view.componentRef.onDestroy(callback);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlldy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9mbGV4LXJlbmRlci92aWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBbUIsV0FBVyxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQTtBQUVsRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQTtBQVk3RCxNQUFNLFVBQVUsMkJBQTJCLENBQ3pDLE9BQStCO0lBRS9CLElBQUksT0FBTyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFLENBQUM7UUFDOUMsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQTtJQUN6QixDQUFDO0lBQ0QsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFLENBQUM7UUFDL0QsT0FBTyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUE7SUFDdkMsQ0FBQztJQUNELElBQUksT0FBTyxZQUFZLG1CQUFtQixFQUFFLENBQUM7UUFDM0MsT0FBTyxFQUFFLElBQUksRUFBRSxxQkFBcUIsRUFBRSxPQUFPLEVBQUUsQ0FBQTtJQUNqRCxDQUFDO1NBQU0sSUFBSSxPQUFPLFlBQVksV0FBVyxFQUFFLENBQUM7UUFDMUMsT0FBTyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLENBQUE7SUFDekMsQ0FBQztTQUFNLElBQUksT0FBTyxZQUFZLElBQUksRUFBRSxDQUFDO1FBQ25DLE9BQU8sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFBO0lBQ3ZDLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUE7SUFDdkMsQ0FBQztBQUNILENBQUM7QUFFRCxNQUFNLE9BQWdCLGNBQWM7SUFHekIsSUFBSSxDQUFPO0lBQ3BCLGdCQUFnQixDQUFvQztJQUNwRCxRQUFRLENBQXdCO0lBRWhDLFlBQ0UsY0FBaUUsRUFDakUsSUFBVztRQUVYLElBQUksQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFBO1FBQzlCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO0lBQ2xCLENBQUM7SUFFRCxJQUFJLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUE7SUFDbEQsQ0FBQztJQUVELElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQTtJQUN0QixDQUFDO0lBRUQsSUFBSSxPQUFPLENBQUMsT0FBK0I7UUFDekMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxRQUFRLENBQUE7UUFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUE7SUFDekIsQ0FBQztDQU9GO0FBRUQsTUFBTSxPQUFPLHNCQUF1QixTQUFRLGNBRTNDO0lBQ0MsWUFDRSxjQUdDLEVBQ0QsSUFBOEI7UUFFOUIsS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUM3QixDQUFDO0lBRVEsV0FBVyxDQUFDLEtBQTBCO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUE7SUFDMUIsQ0FBQztJQUVRLFVBQVU7UUFDakIseUdBQXlHO1FBQ3pHLGtIQUFrSDtRQUNsSCw0Q0FBNEM7UUFDNUMsRUFBRTtRQUNGLHNGQUFzRjtRQUN0RiwyQkFBMkI7SUFDN0IsQ0FBQztJQUVRLFNBQVMsQ0FBQyxRQUFrQjtRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUMvQixDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsY0FFNUM7SUFDQyxZQUNFLGNBR0MsRUFDRCxJQUFxQztRQUVyQyxLQUFLLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQzdCLENBQUM7SUFFUSxXQUFXLENBQUMsS0FBMEI7UUFDN0MsUUFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzFCLEtBQUssV0FBVyxDQUFDLENBQUMsQ0FBQztnQkFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7Z0JBQzFCLE1BQUs7WUFDUCxDQUFDO1lBQ0QsS0FBSyxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLDREQUE0RDtnQkFDNUQseURBQXlEO2dCQUN6RCxNQUFLO1lBQ1AsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRVEsVUFBVTtRQUNqQixRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDMUIsS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUNqQixzRkFBc0Y7Z0JBQ3RGLDhHQUE4RztnQkFDOUcsd0ZBQXdGO2dCQUN4RixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO2dCQUN2QixNQUFLO1lBQ1AsQ0FBQztZQUNELEtBQUsscUJBQXFCLENBQUMsQ0FBQyxDQUFDO2dCQUMzQix1RkFBdUY7Z0JBQ3ZGLGlGQUFpRjtnQkFDakYsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7b0JBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUE7Z0JBQ3hDLENBQUM7Z0JBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQTtnQkFDdkIsTUFBSztZQUNQLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVRLFNBQVMsQ0FBQyxRQUFrQjtRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUE7SUFDNUMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRmxleFJlbmRlckNvbXBvbmVudFJlZiB9IGZyb20gJy4vZmxleC1yZW5kZXItY29tcG9uZW50LXJlZidcbmltcG9ydCB7IEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBGbGV4UmVuZGVyQ29udGVudCB9IGZyb20gJy4uL2ZsZXgtcmVuZGVyJ1xuaW1wb3J0IHsgRmxleFJlbmRlckNvbXBvbmVudCB9IGZyb20gJy4vZmxleC1yZW5kZXItY29tcG9uZW50J1xuXG5leHBvcnQgdHlwZSBGbGV4UmVuZGVyVHlwZWRDb250ZW50ID1cbiAgfCB7IGtpbmQ6ICdudWxsJyB9XG4gIHwge1xuICAgICAga2luZDogJ3ByaW1pdGl2ZSdcbiAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IG51bWJlciB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB9XG4gIHwgeyBraW5kOiAnZmxleFJlbmRlckNvbXBvbmVudCc7IGNvbnRlbnQ6IEZsZXhSZW5kZXJDb21wb25lbnQ8dW5rbm93bj4gfVxuICB8IHsga2luZDogJ3RlbXBsYXRlUmVmJzsgY29udGVudDogVGVtcGxhdGVSZWY8dW5rbm93bj4gfVxuICB8IHsga2luZDogJ2NvbXBvbmVudCc7IGNvbnRlbnQ6IFR5cGU8dW5rbm93bj4gfVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9GbGV4UmVuZGVyVHlwZWRDb250ZW50KFxuICBjb250ZW50OiBGbGV4UmVuZGVyQ29udGVudDxhbnk+XG4pOiBGbGV4UmVuZGVyVHlwZWRDb250ZW50IHtcbiAgaWYgKGNvbnRlbnQgPT09IG51bGwgfHwgY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsga2luZDogJ251bGwnIH1cbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB7IGtpbmQ6ICdwcmltaXRpdmUnLCBjb250ZW50IH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEZsZXhSZW5kZXJDb21wb25lbnQpIHtcbiAgICByZXR1cm4geyBraW5kOiAnZmxleFJlbmRlckNvbXBvbmVudCcsIGNvbnRlbnQgfVxuICB9IGVsc2UgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZikge1xuICAgIHJldHVybiB7IGtpbmQ6ICd0ZW1wbGF0ZVJlZicsIGNvbnRlbnQgfVxuICB9IGVsc2UgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgcmV0dXJuIHsga2luZDogJ2NvbXBvbmVudCcsIGNvbnRlbnQgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGtpbmQ6ICdwcmltaXRpdmUnLCBjb250ZW50IH1cbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRmxleFJlbmRlclZpZXc8XG4gIFRWaWV3IGV4dGVuZHMgRmxleFJlbmRlckNvbXBvbmVudFJlZjxhbnk+IHwgRW1iZWRkZWRWaWV3UmVmPHVua25vd24+IHwgbnVsbCxcbj4ge1xuICByZWFkb25seSB2aWV3OiBUVmlld1xuICAjcHJldmlvdXNDb250ZW50OiBGbGV4UmVuZGVyVHlwZWRDb250ZW50IHwgdW5kZWZpbmVkXG4gICNjb250ZW50OiBGbGV4UmVuZGVyVHlwZWRDb250ZW50XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIGluaXRpYWxDb250ZW50OiBFeGNsdWRlPEZsZXhSZW5kZXJUeXBlZENvbnRlbnQsIHsga2luZDogJ251bGwnIH0+LFxuICAgIHZpZXc6IFRWaWV3XG4gICkge1xuICAgIHRoaXMuI2NvbnRlbnQgPSBpbml0aWFsQ29udGVudFxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgfVxuXG4gIGdldCBwcmV2aW91c0NvbnRlbnQoKTogRmxleFJlbmRlclR5cGVkQ29udGVudCB7XG4gICAgcmV0dXJuIHRoaXMuI3ByZXZpb3VzQ29udGVudCA/PyB7IGtpbmQ6ICdudWxsJyB9XG4gIH1cblxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGVudFxuICB9XG5cbiAgc2V0IGNvbnRlbnQoY29udGVudDogRmxleFJlbmRlclR5cGVkQ29udGVudCkge1xuICAgIHRoaXMuI3ByZXZpb3VzQ29udGVudCA9IHRoaXMuI2NvbnRlbnRcbiAgICB0aGlzLiNjb250ZW50ID0gY29udGVudFxuICB9XG5cbiAgYWJzdHJhY3QgdXBkYXRlUHJvcHMocHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkXG5cbiAgYWJzdHJhY3QgZGlydHlDaGVjaygpOiB2b2lkXG5cbiAgYWJzdHJhY3Qgb25EZXN0cm95KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIEZsZXhSZW5kZXJUZW1wbGF0ZVZpZXcgZXh0ZW5kcyBGbGV4UmVuZGVyVmlldzxcbiAgRW1iZWRkZWRWaWV3UmVmPHVua25vd24+XG4+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5pdGlhbENvbnRlbnQ6IEV4dHJhY3Q8XG4gICAgICBGbGV4UmVuZGVyVHlwZWRDb250ZW50LFxuICAgICAgeyBraW5kOiAncHJpbWl0aXZlJyB8ICd0ZW1wbGF0ZVJlZicgfVxuICAgID4sXG4gICAgdmlldzogRW1iZWRkZWRWaWV3UmVmPHVua25vd24+XG4gICkge1xuICAgIHN1cGVyKGluaXRpYWxDb250ZW50LCB2aWV3KVxuICB9XG5cbiAgb3ZlcnJpZGUgdXBkYXRlUHJvcHMocHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICB0aGlzLnZpZXcubWFya0ZvckNoZWNrKClcbiAgfVxuXG4gIG92ZXJyaWRlIGRpcnR5Q2hlY2soKSB7XG4gICAgLy8gQmFzaWNhbGx5IGEgbm8tb3AuIFdoZW4gdGhlIHZpZXcgaXMgY3JlYXRlZCB2aWEgRW1iZWRkZWRWaWV3UmVmLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBtYW51YWwgdXBkYXRlXG4gICAgLy8gc2luY2UgdGhpcyB0eXBlIG9mIGNvbnRlbnQgaGFzIGEgcHJveHkgYXMgYSBjb250ZXh0LCB0aGVuIGV2ZXJ5IHRpbWUgdGhlIHJvb3QgY29tcG9uZW50IGlzIGNoZWNrZWQgZm9yIGNoYW5nZXMsXG4gICAgLy8gdGhlIHByb3BlcnR5IGdldHRlciB3aWxsIGJlIHJlLWV2YWx1YXRlZC5cbiAgICAvL1xuICAgIC8vIElmIGluIGEgZnV0dXJlIHdlIG5lZWQgdG8gbWFudWFsbHkgbWFyayB0aGUgdmlldyBhcyBkaXJ0eSwganVzdCB1bmNvbW1lbnQgbmV4dCBsaW5lXG4gICAgLy8gdGhpcy52aWV3Lm1hcmtGb3JDaGVjaygpXG4gIH1cblxuICBvdmVycmlkZSBvbkRlc3Ryb3koY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy52aWV3Lm9uRGVzdHJveShjYWxsYmFjaylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmxleFJlbmRlckNvbXBvbmVudFZpZXcgZXh0ZW5kcyBGbGV4UmVuZGVyVmlldzxcbiAgRmxleFJlbmRlckNvbXBvbmVudFJlZjx1bmtub3duPlxuPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluaXRpYWxDb250ZW50OiBFeHRyYWN0PFxuICAgICAgRmxleFJlbmRlclR5cGVkQ29udGVudCxcbiAgICAgIHsga2luZDogJ2NvbXBvbmVudCcgfCAnZmxleFJlbmRlckNvbXBvbmVudCcgfVxuICAgID4sXG4gICAgdmlldzogRmxleFJlbmRlckNvbXBvbmVudFJlZjx1bmtub3duPlxuICApIHtcbiAgICBzdXBlcihpbml0aWFsQ29udGVudCwgdmlldylcbiAgfVxuXG4gIG92ZXJyaWRlIHVwZGF0ZVByb3BzKHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgc3dpdGNoICh0aGlzLmNvbnRlbnQua2luZCkge1xuICAgICAgY2FzZSAnY29tcG9uZW50Jzoge1xuICAgICAgICB0aGlzLnZpZXcuc2V0SW5wdXRzKHByb3BzKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnZmxleFJlbmRlckNvbXBvbmVudCc6IHtcbiAgICAgICAgLy8gTm8tb3AuIFdoZW4gRmxleFJlbmRlckZsYWdzLlByb3BzUmVmZXJlbmNlQ2hhbmdlZCBpcyBzZXQsXG4gICAgICAgIC8vIEZsZXhSZW5kZXJDb21wb25lbnQgd2lsbCBiZSB1cGRhdGVkIGludG8gYGRpcnR5Q2hlY2tgLlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG92ZXJyaWRlIGRpcnR5Q2hlY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLmNvbnRlbnQua2luZCkge1xuICAgICAgY2FzZSAnY29tcG9uZW50Jzoge1xuICAgICAgICAvLyBDb21wb25lbnQgY29udGV4dCBpcyBjdXJyZW50bHkgdmFsdWF0ZWQgd2l0aCB0aGUgY2VsbCBjb250ZXh0LiBTaW5jZSBpdCdzIHJlZmVyZW5jZVxuICAgICAgICAvLyBzaG91bGRuJ3QgY2hhbmdlLCB3ZSBmb3JjZSBtYXJrIHRoZSBjb21wb25lbnQgYXMgZGlydHkgaW4gb3JkZXIgdG8gcmUtZXZhbHVhdGUgZnVuY3Rpb24gaW52b2NhdGlvbiBpbiB2aWV3LlxuICAgICAgICAvLyBOT1RFOiB0aGlzIHNob3VsZCBiZWhhdmUgbGlrZSBoYXZpbmcgYSBjb21wb25lbnQgd2l0aCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0XG4gICAgICAgIHRoaXMudmlldy5tYXJrQXNEaXJ0eSgpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdmbGV4UmVuZGVyQ29tcG9uZW50Jzoge1xuICAgICAgICAvLyBHaXZlbiBjb250ZXh0IGluc3RhbmNlIHdpbGwgYWx3YXlzIGhhdmUgYSBkaWZmZXJlbnQgcmVmZXJlbmNlIHRoYW4gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gc28gaW5zdGVhZCBvZiByZWNyZWF0aW5nIHRoZSBlbnRpcmUgdmlldywgd2Ugd2lsbCBvbmx5IHVwZGF0ZSB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgIGlmICh0aGlzLnZpZXcuZXFUeXBlKHRoaXMuY29udGVudC5jb250ZW50KSkge1xuICAgICAgICAgIHRoaXMudmlldy51cGRhdGUodGhpcy5jb250ZW50LmNvbnRlbnQpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3Lm1hcmtBc0RpcnR5KClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvdmVycmlkZSBvbkRlc3Ryb3koY2FsbGJhY2s6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy52aWV3LmNvbXBvbmVudFJlZi5vbkRlc3Ryb3koY2FsbGJhY2spXG4gIH1cbn1cbiJdfQ==