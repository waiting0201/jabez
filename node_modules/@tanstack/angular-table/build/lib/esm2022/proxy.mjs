import { computed, untracked } from '@angular/core';
export function proxifyTable(tableSignal) {
    const internalState = tableSignal;
    return new Proxy(internalState, {
        apply() {
            return tableSignal();
        },
        get(target, property) {
            if (target[property]) {
                return target[property];
            }
            const table = untracked(tableSignal);
            /**
             * Attempt to convert all accessors into computed ones,
             * excluding handlers as they do not retain any reactive value
             */
            if (property.startsWith('get') &&
                !property.endsWith('Handler')
            // e.g. getCoreRowModel, getSelectedRowModel etc.
            // We need that after a signal change even `rowModel` may mark the view as dirty.
            // This allows to always get the latest `getContext` value while using flexRender
            // && !property.endsWith('Model')
            ) {
                const maybeFn = table[property];
                if (typeof maybeFn === 'function') {
                    Object.defineProperty(target, property, {
                        value: toComputed(tableSignal, maybeFn),
                        configurable: true,
                        enumerable: true,
                    });
                    return target[property];
                }
            }
            // @ts-expect-error
            return (target[property] = table[property]);
        },
        has(_, prop) {
            return !!untracked(tableSignal)[prop];
        },
        ownKeys() {
            return Reflect.ownKeys(untracked(tableSignal));
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: true,
                configurable: true,
            };
        },
    });
}
/**
 * Here we'll handle all type of accessors:
 * - 0 argument -> e.g. table.getCanNextPage())
 * - 0~1 arguments -> e.g. table.getIsSomeRowsPinned(position?)
 * - 1 required argument -> e.g. table.getColumn(columnId)
 * - 1+ argument -> e.g. table.getRow(id, searchAll?)
 *
 * Since we are not able to detect automatically the accessors parameters,
 * we'll wrap all accessors into a cached function wrapping a computed
 * that return it's value based on the given parameters
 */
function toComputed(signal, fn) {
    const hasArgs = fn.length > 0;
    if (!hasArgs) {
        return computed(() => {
            void signal();
            return fn();
        });
    }
    const computedCache = {};
    return (...argsArray) => {
        const serializedArgs = serializeArgs(...argsArray);
        if (computedCache.hasOwnProperty(serializedArgs)) {
            return computedCache[serializedArgs]?.();
        }
        const computedSignal = computed(() => {
            void signal();
            return fn(...argsArray);
        });
        computedCache[serializedArgs] = computedSignal;
        return computedSignal();
    };
}
function serializeArgs(...args) {
    return JSON.stringify(args);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJveHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBZSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUE7QUFLaEUsTUFBTSxVQUFVLFlBQVksQ0FDMUIsV0FBNkI7SUFFN0IsTUFBTSxhQUFhLEdBQUcsV0FBNkIsQ0FBQTtJQUVuRCxPQUFPLElBQUksS0FBSyxDQUFDLGFBQWEsRUFBRTtRQUM5QixLQUFLO1lBQ0gsT0FBTyxXQUFXLEVBQUUsQ0FBQTtRQUN0QixDQUFDO1FBQ0QsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUF3QjtZQUNsQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO2dCQUNyQixPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUN6QixDQUFDO1lBQ0QsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFBO1lBQ3BDOzs7ZUFHRztZQUNILElBQ0UsUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7Z0JBQzFCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFDN0IsaURBQWlEO1lBQ2pELGlGQUFpRjtZQUNqRixpRkFBaUY7WUFDakYsaUNBQWlDO2NBQ2pDLENBQUM7Z0JBQ0QsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBcUIsQ0FBQTtnQkFDbkQsSUFBSSxPQUFPLE9BQU8sS0FBSyxVQUFVLEVBQUUsQ0FBQztvQkFDbEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFO3dCQUN0QyxLQUFLLEVBQUUsVUFBVSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7d0JBQ3ZDLFlBQVksRUFBRSxJQUFJO3dCQUNsQixVQUFVLEVBQUUsSUFBSTtxQkFDakIsQ0FBQyxDQUFBO29CQUNGLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO2dCQUN6QixDQUFDO1lBQ0gsQ0FBQztZQUNELG1CQUFtQjtZQUNuQixPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFBO1FBQzdDLENBQUM7UUFDRCxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQW9CO1lBQ3pCLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUN2QyxDQUFDO1FBQ0QsT0FBTztZQUNMLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQTtRQUNoRCxDQUFDO1FBQ0Qsd0JBQXdCO1lBQ3RCLE9BQU87Z0JBQ0wsVUFBVSxFQUFFLElBQUk7Z0JBQ2hCLFlBQVksRUFBRSxJQUFJO2FBQ25CLENBQUE7UUFDSCxDQUFDO0tBQ0YsQ0FBQyxDQUFBO0FBQ0osQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFTLFVBQVUsQ0FBSSxNQUF3QixFQUFFLEVBQVk7SUFDM0QsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7SUFDN0IsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2IsT0FBTyxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ25CLEtBQUssTUFBTSxFQUFFLENBQUE7WUFDYixPQUFPLEVBQUUsRUFBRSxDQUFBO1FBQ2IsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBRUQsTUFBTSxhQUFhLEdBQW9DLEVBQUUsQ0FBQTtJQUV6RCxPQUFPLENBQUMsR0FBRyxTQUFnQixFQUFFLEVBQUU7UUFDN0IsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUE7UUFDbEQsSUFBSSxhQUFhLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUM7WUFDakQsT0FBTyxhQUFhLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxDQUFBO1FBQzFDLENBQUM7UUFDRCxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQ25DLEtBQUssTUFBTSxFQUFFLENBQUE7WUFDYixPQUFPLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFBO1FBQ3pCLENBQUMsQ0FBQyxDQUFBO1FBRUYsYUFBYSxDQUFDLGNBQWMsQ0FBQyxHQUFHLGNBQWMsQ0FBQTtRQUU5QyxPQUFPLGNBQWMsRUFBRSxDQUFBO0lBQ3pCLENBQUMsQ0FBQTtBQUNILENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxHQUFHLElBQVc7SUFDbkMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzdCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlZCwgdHlwZSBTaWduYWwsIHVudHJhY2tlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnXG5pbXBvcnQgeyB0eXBlIFRhYmxlIH0gZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnXG5cbnR5cGUgVGFibGVTaWduYWw8VD4gPSBUYWJsZTxUPiAmIFNpZ25hbDxUYWJsZTxUPj5cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3hpZnlUYWJsZTxUPihcbiAgdGFibGVTaWduYWw6IFNpZ25hbDxUYWJsZTxUPj5cbik6IFRhYmxlPFQ+ICYgU2lnbmFsPFRhYmxlPFQ+PiB7XG4gIGNvbnN0IGludGVybmFsU3RhdGUgPSB0YWJsZVNpZ25hbCBhcyBUYWJsZVNpZ25hbDxUPlxuXG4gIHJldHVybiBuZXcgUHJveHkoaW50ZXJuYWxTdGF0ZSwge1xuICAgIGFwcGx5KCkge1xuICAgICAgcmV0dXJuIHRhYmxlU2lnbmFsKClcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5OiBrZXlvZiBUYWJsZTxUPik6IGFueSB7XG4gICAgICBpZiAodGFyZ2V0W3Byb3BlcnR5XSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XVxuICAgICAgfVxuICAgICAgY29uc3QgdGFibGUgPSB1bnRyYWNrZWQodGFibGVTaWduYWwpXG4gICAgICAvKipcbiAgICAgICAqIEF0dGVtcHQgdG8gY29udmVydCBhbGwgYWNjZXNzb3JzIGludG8gY29tcHV0ZWQgb25lcyxcbiAgICAgICAqIGV4Y2x1ZGluZyBoYW5kbGVycyBhcyB0aGV5IGRvIG5vdCByZXRhaW4gYW55IHJlYWN0aXZlIHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGlmIChcbiAgICAgICAgcHJvcGVydHkuc3RhcnRzV2l0aCgnZ2V0JykgJiZcbiAgICAgICAgIXByb3BlcnR5LmVuZHNXaXRoKCdIYW5kbGVyJylcbiAgICAgICAgLy8gZS5nLiBnZXRDb3JlUm93TW9kZWwsIGdldFNlbGVjdGVkUm93TW9kZWwgZXRjLlxuICAgICAgICAvLyBXZSBuZWVkIHRoYXQgYWZ0ZXIgYSBzaWduYWwgY2hhbmdlIGV2ZW4gYHJvd01vZGVsYCBtYXkgbWFyayB0aGUgdmlldyBhcyBkaXJ0eS5cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdG8gYWx3YXlzIGdldCB0aGUgbGF0ZXN0IGBnZXRDb250ZXh0YCB2YWx1ZSB3aGlsZSB1c2luZyBmbGV4UmVuZGVyXG4gICAgICAgIC8vICYmICFwcm9wZXJ0eS5lbmRzV2l0aCgnTW9kZWwnKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1heWJlRm4gPSB0YWJsZVtwcm9wZXJ0eV0gYXMgRnVuY3Rpb24gfCBuZXZlclxuICAgICAgICBpZiAodHlwZW9mIG1heWJlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgdmFsdWU6IHRvQ29tcHV0ZWQodGFibGVTaWduYWwsIG1heWJlRm4pLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJldHVybiAodGFyZ2V0W3Byb3BlcnR5XSA9IHRhYmxlW3Byb3BlcnR5XSlcbiAgICB9LFxuICAgIGhhcyhfLCBwcm9wOiBrZXlvZiBUYWJsZTxUPikge1xuICAgICAgcmV0dXJuICEhdW50cmFja2VkKHRhYmxlU2lnbmFsKVtwcm9wXVxuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModW50cmFja2VkKHRhYmxlU2lnbmFsKSlcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEhlcmUgd2UnbGwgaGFuZGxlIGFsbCB0eXBlIG9mIGFjY2Vzc29yczpcbiAqIC0gMCBhcmd1bWVudCAtPiBlLmcuIHRhYmxlLmdldENhbk5leHRQYWdlKCkpXG4gKiAtIDB+MSBhcmd1bWVudHMgLT4gZS5nLiB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkKHBvc2l0aW9uPylcbiAqIC0gMSByZXF1aXJlZCBhcmd1bWVudCAtPiBlLmcuIHRhYmxlLmdldENvbHVtbihjb2x1bW5JZClcbiAqIC0gMSsgYXJndW1lbnQgLT4gZS5nLiB0YWJsZS5nZXRSb3coaWQsIHNlYXJjaEFsbD8pXG4gKlxuICogU2luY2Ugd2UgYXJlIG5vdCBhYmxlIHRvIGRldGVjdCBhdXRvbWF0aWNhbGx5IHRoZSBhY2Nlc3NvcnMgcGFyYW1ldGVycyxcbiAqIHdlJ2xsIHdyYXAgYWxsIGFjY2Vzc29ycyBpbnRvIGEgY2FjaGVkIGZ1bmN0aW9uIHdyYXBwaW5nIGEgY29tcHV0ZWRcbiAqIHRoYXQgcmV0dXJuIGl0J3MgdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gdG9Db21wdXRlZDxUPihzaWduYWw6IFNpZ25hbDxUYWJsZTxUPj4sIGZuOiBGdW5jdGlvbikge1xuICBjb25zdCBoYXNBcmdzID0gZm4ubGVuZ3RoID4gMFxuICBpZiAoIWhhc0FyZ3MpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgdm9pZCBzaWduYWwoKVxuICAgICAgcmV0dXJuIGZuKClcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgY29tcHV0ZWRDYWNoZTogUmVjb3JkPHN0cmluZywgU2lnbmFsPHVua25vd24+PiA9IHt9XG5cbiAgcmV0dXJuICguLi5hcmdzQXJyYXk6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFyZ3MgPSBzZXJpYWxpemVBcmdzKC4uLmFyZ3NBcnJheSlcbiAgICBpZiAoY29tcHV0ZWRDYWNoZS5oYXNPd25Qcm9wZXJ0eShzZXJpYWxpemVkQXJncykpIHtcbiAgICAgIHJldHVybiBjb21wdXRlZENhY2hlW3NlcmlhbGl6ZWRBcmdzXT8uKClcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWRTaWduYWwgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICB2b2lkIHNpZ25hbCgpXG4gICAgICByZXR1cm4gZm4oLi4uYXJnc0FycmF5KVxuICAgIH0pXG5cbiAgICBjb21wdXRlZENhY2hlW3NlcmlhbGl6ZWRBcmdzXSA9IGNvbXB1dGVkU2lnbmFsXG5cbiAgICByZXR1cm4gY29tcHV0ZWRTaWduYWwoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZ3MoLi4uYXJnczogYW55W10pIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3MpXG59XG4iXX0=